<!DOCTYPE html>
<html>
<head>
	<style>
		body {
			font-family: Arial;
		}
		ul {
			width: 300px;
			padding: 10px;
			list-style: none;
			line-height: 30px;
			background: #f3f3f3;
		}
		li > input[type=text] {
			width: 250px;
		}
		.delete-button {
			float: right;
			cursor: pointer;
		}
		.filter {
			margin-right: 10px;
		}
		.filter:not(.active) {
			color: blue;
			cursor: pointer;
			text-decoration: underline;
		}
	</style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<script src="https://rawgit.com/ken107/kenna-js/master/databind.js"></script>
	<script src="components.js"></script>
	<script>
		//load components
		dataBinder.templateInheritsData = false;
		dataBinder.autoBind = false;
		$("<div/>").load("components.html", function() {
			$(this).children().each(function() {
				var className = this.getAttribute("data-class");
				if (className) {
					this.setAttribute("bind-context", "new " + className + "(thisElem, data)");
					dataBinder.templates[className] = this;
				}
			});
			dataBinder.autoBind = true;
		});
	</script>
	<script>
		//model
		items = [];
		currentFilter = 'All';
		filteredItems = [];
		countActive = 0;
		
		//controller
		function setFilter(filter) {
			currentFilter = filter;
			update();
		}
		function addItem(text) {
			items.push({text: text});
			update();
		}
		function deleteItem(item) {
			items.splice(items.indexOf(item), 1);
			update();
		}
		function setCompleted(item, completed) {
			item.completed = completed;
			update();
		}
		function update() {
			filteredItems = items.filter(function(item) {
				return currentFilter == 'All' || currentFilter == 'Active' && !item.completed || currentFilter == 'Completed' && !!item.completed;
			});
			countActive = items.filter(function(item) {
				return !item.completed;
			}).length;
		}
	</script>
</head>
<body>
	<!--
		This example demonstrates an important design pattern:
		Child components generally do not have total knowledge of how an event affects the model.  So when an event occurs,
		instead of directly updating the model, events should be propagated up and be handled by the parent controller.
		
		There are ways to do it without following this pattern, the framework allows all.  However, it results in code
		that are rather kludgey.
	-->
	<h1>TODO</h1>
	<div bind-template="Filters"
		bind-param-current-filter="#currentFilter"
		bind-event-set-filter="setFilter(event.data)">
	</div>
	<div bind-template="TodoList"
		bind-param-items="#filteredItems"
		bind-event-add-item="addItem(event.data)"
		bind-event-delete-item="deleteItem(event.data)"
		bind-event-set-completed="setCompleted(event.data.item, event.data.completed)">
	</div>
	<div>{{#countActive}} things to do</div>
</body>
</html>
